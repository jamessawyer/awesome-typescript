import{_ as s,a}from"./chunks/10-17.dd9c15a5.js";import{_ as n}from"./chunks/10-13.153a4ea8.js";import{_ as p,c as l,o,N as e}from"./chunks/framework.8a34944b.js";const t="/awesome-typescript/assets/10-2.3dba4c7b.webp",c="/awesome-typescript/assets/10-3.07d07adb.webp",r="/awesome-typescript/assets/10-4.14ca0983.webp",y="/awesome-typescript/assets/10-5.782fdacb.webp",C="/awesome-typescript/assets/10-6.4799762e.webp",A="/awesome-typescript/assets/10-7.14311d3e.webp",F="/awesome-typescript/assets/10-8.7f7f5502.webp",D="/awesome-typescript/assets/10-9.9084c1ff.webp",i="/awesome-typescript/assets/10-10.2654459f.webp",B="/awesome-typescript/assets/10-11.7a3febd3.webp",d="/awesome-typescript/assets/10-12.300b8687.webp",g="/awesome-typescript/assets/10-20.118f2627.webp",u="/awesome-typescript/assets/10-14.01a13d40.webp",b="/awesome-typescript/assets/10-15.37780cc8.webp",h="/awesome-typescript/assets/10-16.dcb3d654.webp",m="/awesome-typescript/assets/10-18.74efa397.webp",E="/awesome-typescript/assets/10-19.f3ab4346.webp",P=JSON.parse('{"title":"特殊特性","description":"","frontmatter":{"title":"特殊特性"},"headers":[],"relativePath":"book/master-ts/10.md","lastUpdated":1679536477000}'),v={name:"book/master-ts/10.md"},f=e(`<p>我们会了提取、构造、递归、数组长度的计数、联合类型的分散之后，各种类型体操都能写了 ，只不过有些类型的特性比较特殊，要专门记一下。</p><p>这是类型体操的第六个套路：<strong>特殊特性要记清</strong>。</p><h2 id="特殊类型的特性" tabindex="-1">特殊类型的特性 <a class="header-anchor" href="#特殊类型的特性" aria-label="Permalink to &quot;特殊类型的特性&quot;">​</a></h2><p>TypeScript 类型系统中有些类型比较特殊，</p><ul><li>比如 any、never、联合类型，</li><li>比如 class 有 public、protected、private 的属性，</li><li>比如索引类型有具体的索引和可索引签名，索引还有可选和非可选。。。</li></ul><p>如果给我们一种类型让我们判断是什么类型，应该怎么做呢？</p><p><strong>类型的判断要根据它的特性来，比如判断联合类型就要根据它的 <code>distributive</code> 的特性。</strong></p><p>我们分别看一下这些特性：</p><h2 id="isany" tabindex="-1">IsAny <a class="header-anchor" href="#isany" aria-label="Permalink to &quot;IsAny&quot;">​</a></h2><p>如何判断一个类型是 any 类型呢？要根据它的特性来：</p><p>📚 <strong>any 类型与任何类型的交叉都是 any，也就是 <code>1 &amp; any</code> 结果是 any。</strong></p><p>所以，可以这样写：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">IsAny</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">T</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">x</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> (</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">y</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">any</span><span style="color:#A6ACCD;">) </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">true</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">false</span></span>
<span class="line"></span></code></pre></div><p>这里的 &#39;x&#39; 和 &#39;y&#39; 可以换成任意类型。</p><p>当传入 any 时：</p><p><img src="`+s+'" alt="IsAny"></p><p>当传入其他类型时：</p><p><img src="'+t+`" alt="IsAny false"></p><h2 id="isequal" tabindex="-1">IsEqual <a class="header-anchor" href="#isequal" aria-label="Permalink to &quot;IsEqual&quot;">​</a></h2><p>之前我们实现 <a href="./7.html#⚡-includes">IsEqual</a> 是这样写的：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">IsEqual</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">A</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">B</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">  (</span><span style="color:#FFCB6B;">A</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">B</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">true</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">false</span><span style="color:#A6ACCD;">) </span><span style="color:#89DDFF;">&amp;</span><span style="color:#A6ACCD;"> (</span><span style="color:#FFCB6B;">B</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">A</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">true</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">false</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p>问题也出在 <code>any</code> 的判断上：</p><p><img src="`+c+`" alt="IsEqual problem"></p><p><strong>因为 any 可以是任何类型，任何类型也都是 any，所以当这样写判断不出 any 类型来。</strong></p><p>所以，我们会这样写：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">IsEqual2</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">A</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">B</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span></span>
<span class="line"><span style="color:#A6ACCD;">  (</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">T</span><span style="color:#89DDFF;">&gt;()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">T</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">A</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">) </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> (</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">T</span><span style="color:#89DDFF;">&gt;()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">T</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">B</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">true</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">false</span></span>
<span class="line"></span></code></pre></div><p>这样就能正常判断了：</p><p><img src="`+r+`" alt="IsEqual OK"></p><p>这是因为 TS 对这种形式的类型做了特殊处理，是一种 hack 的写法，它的解释要从 TypeScript 源码找答案了，放到原理篇我们一起读下 TypeScript 源码。这里暂时就这样写吧。</p><h2 id="isunion" tabindex="-1">IsUnion <a class="header-anchor" href="#isunion" aria-label="Permalink to &quot;IsUnion&quot;">​</a></h2><p>还记得怎么判断 <a href="./9.html#⚡-isunion">union</a> 类型么？要根据它遇到条件类型时会分散成单个传入做计算的特性：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">IsUnion</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">A</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">B</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">A</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">A</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">A</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> [</span><span style="color:#FFCB6B;">B</span><span style="color:#A6ACCD;">] </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> [</span><span style="color:#FFCB6B;">A</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">false</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">true</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">never</span></span>
<span class="line"></span></code></pre></div><ul><li>这里的 A 是单个类型，B 是整个联合类型，所以根据 <code>[B] extends [A]</code> 是否成立来判断是否是联合类型。</li></ul><p><img src="`+y+'" alt="IsUnion"></p><p>当传入单个类型时：</p><p><img src="'+C+`" alt="IsUnion false"></p><h2 id="isnever" tabindex="-1">IsNever <a class="header-anchor" href="#isnever" aria-label="Permalink to &quot;IsNever&quot;">​</a></h2><p>📚<code>never</code> 在条件类型中也比较特殊，如果条件类型左边是类型参数，并且传入的是 never，那么直接返回 never：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">TestNever</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">T</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">T</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">number</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span></span>
<span class="line"></span></code></pre></div><p>当 T 为 never 时：</p><p><img src="`+A+`" alt="TestNever"></p><p>所以，要判断 never 类型，就不能直接 T extends number，可以这样写：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">IsNever</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">T</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> [</span><span style="color:#FFCB6B;">T</span><span style="color:#A6ACCD;">] </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> [</span><span style="color:#FFCB6B;">never</span><span style="color:#A6ACCD;">] </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">true</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">false</span></span>
<span class="line"></span></code></pre></div><p>这样就能正常判断 never 类型了：</p><p><img src="`+F+`" alt="IsNever"></p><p>📚除此以外，<strong>any 在条件类型中也比较特殊，如果类型参数为 any，会直接返回 trueType 和 falseType 的合并</strong>：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">TestAny</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">T</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">T</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">number</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span></span>
<span class="line"></span></code></pre></div><p><img src="`+D+'" alt="TestAny"></p><p>联合类型、never、any 在作为条件类型的类型参数时的这些特殊情况，也会在后面的原理篇来解释原因。</p><h2 id="⚡-istuple" tabindex="-1">⚡ IsTuple <a class="header-anchor" href="#⚡-istuple" aria-label="Permalink to &quot;⚡ IsTuple&quot;">​</a></h2><p>元组类型怎么判断呢？它和数组有什么区别呢？</p><ul><li><strong>元组类型也是数组类型，但每个元素都是<code>只读</code>的，并且 <code>length</code> 是数字字面量，而数组的 length 是 number。</strong></li></ul><p>第一个特性，元组类型也是数组类型，并且每个元素都是只读，这个很好理解。</p><p>我们重点来看第二个特性：</p><p><img src="'+i+`" alt="Tuple vs Array"></p><p>如图，元组和数组的 <code>length</code> 属性值是有区别的。</p><p>那我们就可以根据这两个特性来判断元组类型：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">IsTuple</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">T</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">T</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">readonly</span><span style="color:#A6ACCD;"> [</span><span style="color:#89DDFF;">...</span><span style="color:#FFCB6B;">params</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">infer</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Eles</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">NotEqual</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Eles</span><span style="color:#A6ACCD;">[</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">length</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">number</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">false</span></span>
<span class="line"></span></code></pre></div><ul><li>类型参数 T 是要判断的类型。</li><li>首先判断 T 是否是数组类型，如果不是则返回 false。如果是继续判断 length 属性是否是 number。</li><li>如果是数组并且 length 不是 number 类型，那就代表 T 是元组。</li></ul><p><code>NotEqual</code> 的实现是这样的：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">NotEqual</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">A</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">B</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span></span>
<span class="line"><span style="color:#A6ACCD;">  (</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">T</span><span style="color:#89DDFF;">&gt;()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">T</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">A</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">) </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> (</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">T</span><span style="color:#89DDFF;">&gt;()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">T</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">B</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">false</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">true</span></span>
<span class="line"></span></code></pre></div><ul><li>A 是 B 类型，并且 B 也是 A 类型，那么就是同一个类型，返回 false，否则返回 true。</li></ul><p>这样就可以判断出元组类型：</p><p>当传入<strong>元组</strong>时：</p><p><img src="`+B+'" alt="IsTuple true"></p><p>当传入<strong>数组</strong>时：</p><p><img src="'+d+`" alt="IsTuple false"></p><h2 id="uniontointersection" tabindex="-1">UnionToIntersection <a class="header-anchor" href="#uniontointersection" aria-label="Permalink to &quot;UnionToIntersection&quot;">​</a></h2><p>📚 <strong>类型之间是有父子关系的，更具体的那个是子类型，比如 A 和 B 的交叉类型 <code>A &amp; B</code> 就是联合类型 <code>A | B</code> 的子类型，因为更具体。</strong></p><ul><li>如果允许父类型赋值给子类型，就叫做<strong>逆变</strong>。</li><li>如果允许子类型赋值给父类型，就叫做<strong>协变</strong>。</li><li>（关于逆变、协变等概念的详细解释可以看原理篇）</li></ul><p>📚在 TypeScript 中有<strong>函数参数是有逆变的性质</strong>的，也就是如果参数可能是多个类型，参数类型会变成它们的交叉类型。</p><p>所以联合转交叉可以这样实现 ：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">UnionToIntersection</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">U</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span></span>
<span class="line"><span style="color:#A6ACCD;">  (</span><span style="color:#FFCB6B;">U</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">U</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">x</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">U</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">unknown</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">never</span><span style="color:#A6ACCD;">) </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">x</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">infer</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">R</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">unknown</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">R</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">never</span></span>
<span class="line"></span></code></pre></div><ul><li>类型参数 U 是要转换的联合类型。</li><li>U extends U 是为了触发联合类型的 distributive 的性质，让每个类型单独传入做计算，最后合并。</li><li>利用 U 做为参数构造个函数，通过模式匹配取参数的类型。</li></ul><p>结果就是交叉类型：</p><p><img src="`+n+'" alt="UnionToIntersection"></p><p>函数参数的逆变性质一般就联合类型转交叉类型会用，记住就行。</p><h2 id="⚡-getoptional" tabindex="-1">⚡ GetOptional <a class="header-anchor" href="#⚡-getoptional" aria-label="Permalink to &quot;⚡ GetOptional&quot;">​</a></h2><p>如何提取索引类型中的可选索引呢？</p><p>这也要利用可选索引的特性：<strong>可选索引的值为 undefined 和值类型的联合类型</strong>。</p><p><img src="'+g+`" alt="Optional Type"></p><p>过滤可选索引，就要构造一个新的索引类型，过程中做过滤：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">GetOptional</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Obj</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Record</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">string</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">any</span><span style="color:#89DDFF;">&gt;&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  [</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#FFCB6B;">Key</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">in</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">keyof</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Obj</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">as</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Pick</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Key</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Key</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">never</span></span>
<span class="line"><span style="color:#A6ACCD;">  ]</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Obj</span><span style="color:#A6ACCD;">[</span><span style="color:#FFCB6B;">Key</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><ul><li>类型参数 Obj 为待处理的索引类型，类型约束为索引为 string、值为任意类型的索引类型 <code>Record&lt;string, any&gt;</code></li><li>用<strong>映射</strong>类型的语法重新构造索引类型，索引是之前的索引也就是 <code>Key in keyof Obj</code>，但要做一些<strong>过滤</strong>，也就是 <code>as</code> 之后的部分</li><li>过滤的方式就是单独取出该索引之后，判断空对象是否是其子类型</li><li>这里的 Pick 是 ts 提供的内置高级类型，就是取出某个 Key 构造新的索引类型</li></ul><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Pick</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">T</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">K</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">keyof</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">T</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> [</span><span style="color:#FFCB6B;">P</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">in</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">K</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">T</span><span style="color:#A6ACCD;">[</span><span style="color:#FFCB6B;">P</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>比如单独取出 age 构造的新的索引类型是这样的：</p><p><img src="`+u+'" alt="Pick"></p><p>📚因为 age 可能为 undefined，也就是索引类型可能是 {}，所以 <code>{} extends Pick&lt;Obj, Key&gt;</code> 就能过滤出可选索引。（可选的意思就是有或者没有，没有的时候就是空的索引类型）</p><p>值的类型依然是之前的，也就是 Obj[Key]。</p><p>这样，就能过滤出所有可选索引，构造成新的索引类型</p><p><img src="'+b+`" alt="GetOptional"></p><h2 id="getrequired" tabindex="-1">GetRequired <a class="header-anchor" href="#getrequired" aria-label="Permalink to &quot;GetRequired&quot;">​</a></h2><p>实现了 <code>GetOptional</code>，那反过来就是 <code>GetRequired</code>，也就是过滤所有非可选的索引构造成新的索引类型：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 注意这里的 Obj 是可以写在后面的</span></span>
<span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">IsRequired</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Key</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">keyof</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Obj</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">{}</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Pick</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Key</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">never</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Key</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">GetRequired</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Obj</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Record</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">string</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">any</span><span style="color:#89DDFF;">&gt;&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  [</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#FFCB6B;">Key</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">in</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">keyof</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Obj</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">as</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">IsRequired</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Key</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Obj</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  ]</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Obj</span><span style="color:#A6ACCD;">[</span><span style="color:#FFCB6B;">Key</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>这样就过滤出了非可选类型：</p><p><img src="`+h+`" alt="GetRequired"></p><h2 id="removeindexsignature" tabindex="-1">RemoveIndexSignature <a class="header-anchor" href="#removeindexsignature" aria-label="Permalink to &quot;RemoveIndexSignature&quot;">​</a></h2><p>索引类型可能有索引，也可能有可索引签名。</p><p>比如：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Dong</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  [</span><span style="color:#A6ACCD;font-style:italic;">key</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">string</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">any</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 可索引签名</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">sleep</span><span style="color:#89DDFF;">():</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">void</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 具体的索引</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>这里的 sleep 是具体的索引，<code>[key: string]: any</code> 就是可索引签名，代表可以添加任意个 string 类型的索引。</p><p>如果想删除索引类型中的可索引签名呢？</p><p>📚 同样根据它的性质，<strong>索引签名不能构造成字符串字面量类型，因为它没有名字，而其他索引可以。</strong></p><p>所以，就可以这样过滤：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">RemoveIndexSignature</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Obj</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Record</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">string</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">any</span><span style="color:#89DDFF;">&gt;&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  [</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#FFCB6B;">Key</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">in</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">keyof</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Obj</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#FFCB6B;">as</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Key</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">\`\${</span><span style="color:#89DDFF;">infer</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Str</span><span style="color:#89DDFF;">}\`</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Str</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">never</span></span>
<span class="line"><span style="color:#A6ACCD;">  ]</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Obj</span><span style="color:#A6ACCD;">[</span><span style="color:#FFCB6B;">Key</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><ul><li>类型参数 Obj 是待处理的索引类型，约束为 <code>Record&lt;string, any&gt;</code></li><li>通过映射类型语法构造新的索引类型，索引是之前的索引 <code>Key in keyof Obj</code>，但要做一些过滤，也就是 as 之后的部分</li><li>如果索引是字符串字面量类型，那么就保留，否则返回 never，代表过滤掉</li><li>值保持不变，也就是 Obj[Key]</li></ul><p>这样就可以过滤掉可索引签名：</p><p><img src="`+a+`" alt="RemoveIndexSignature"></p><h2 id="classpublicprops" tabindex="-1">ClassPublicProps <a class="header-anchor" href="#classpublicprops" aria-label="Permalink to &quot;ClassPublicProps&quot;">​</a></h2><p>如何过滤出 class 的 public 的属性呢？</p><p>也同样是根据它的特性：<strong>keyof 只能拿到 class 的 public 索引，private 和 protected 的索引会被忽略</strong>。</p><p>比如这样一个 class：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Dong</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">string</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">protected</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">age</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">number</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">hobbies</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">string</span><span style="color:#A6ACCD;">[]</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">constructor</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">dong</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">age</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">20</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">hobbies</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> [</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">sleep</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">eat</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">]</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>keyof 拿到的只有 name：</p><p><img src="`+m+`" alt="keyof class"></p><p>所以，我们就可以根据这个特性实现 public 索引的过滤：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ClassPublicProps</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Obj</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Record</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">string</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">any</span><span style="color:#89DDFF;">&gt;&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  [</span><span style="color:#FFCB6B;">key</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">in</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">keyof</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Obj</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Obj</span><span style="color:#A6ACCD;">[</span><span style="color:#FFCB6B;">Key</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><ul><li>类型参数 Obj 为带处理的索引类型，<strong>类和对象都是索引类型</strong>，约束为 <code>Record&lt;string, any&gt;</code></li><li>构造新的索引类型，索引是 <code>keyof Obj</code> 过滤出的索引，也就是 public 的索引</li><li>值保持不变，依然是 Obj[Key]</li></ul><p>这样就能过滤出 public 的属性：</p><p><img src="`+E+'" alt="ClassPublicProps"></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>学完前面 5 个套路，我们已经能够实现各种类型编程逻辑了，但一些类型的特性还是要记一下。在判断或者过滤类型的时候会用到：</p><ol><li><code>any</code> 类型与任何类型的交叉都是 any，也就是 <code>1 &amp; any</code> 结果是 any，可以用这个特性判断 any 类型</li><li>联合类型作为类型参数出现在条件类型左侧时，会分散成单个类型传入，最后合并</li><li><code>never</code> 作为类型参数出现在条件类型左侧时，会直接返回 never</li><li>any 作为类型参数出现在条件类型左侧时，会直接返回 trueType 和 falseType 的联合类型🤩</li><li><code>元组类型</code>也是数组类型，但每个元素都是只读的，并且 length 是数字字面量，而数组的 length 是 number。可以用来判断元组类型</li><li>函数参数处会发生逆变，可以用来实现联合类型转交叉类型</li><li>可选索引的值为 undefined 和值类型的联合类型。可以用来过滤可选索引，反过来也可以过滤非可选索引</li><li>索引类型的索引为字符串字面量类型，而可索引签名不是，可以用这个特性过滤掉可索引签名</li><li>keyof 只能拿到 class 的 public 的索引，可以用来过滤出 public 的属性</li></ol><p>这些类型的特性要专门记一下，其实过两遍就记住了。</p><p>熟悉了这些特殊的特性，配合提取、构造、递归、数组长度计数、联合分散这五种套路，就可以实现各种类型体操。</p><ul><li><a href="https://www.typescriptlang.org/play?#code/PTAEEkGcEEDsE8BQAXeAHAphGCA8AVAPlAF5QByAEwHtYBzc0DAD2Q1kslAApy6BXAIb1GAMlD4AlKAD8oZACd+WAFygAZoIA2kDIhTosUOPABKGSPy3JS2E7mHxCAbn2pMdhOcvWATLeM8PiERF30QbABRAEchLQMPKBi43GgAGlAAIWIybmgmVnZOLNlQAEZQNV9pcW5MgrYOLny5CqrJVwSjSGTtbwCe2O1cckFyDMcwrqihrV9UjOzbbgJCbmkSYnwGoubSttBqnaaeVfXSLePi+tbKw8lEUCfSxWU7zR0MTvdu3rn+shJWbzUbjUCTToRKAAVVgAEtaNMYfDaAsSmRoDlHs98ixGsVoNjns85ABtTIAXSuXFJ0ApROJjLkH10DMZzzUrz07KealgGAAbhgFG5DNhYQjYN4rDZAZAJajyNBGAAfCiZchhH7ilFSiwy-xyhWwEbKqYgKAAOUFwqRkGtQoUq1spPwVLxu1ApP5jqpci5720rLtDuF0usA1DTp9wq1YqtNoU4eQhuwUYcCCm2vwFmQ9iItm2HpOsH4AFsAEbC-Z3XzfMU5yB5rwWQu5+wQ8LAKD4fhoLR6bUD2AusppXxpADMFNJ5GHdGQAAtyBT6x5h6nS5XhaSZ3P2Avl-S7b3+xhnWQGUXCicFBhBDRYFp4F6AHTvtCCBSCMuQNRw2B1GrSIB0gKk2RJUBLWoZA-lwECLFneclxXDItyrBRiAg3kNCDL5RQ8aDYNmNElkvYkViIc5NgkalQBacpa2kYtikotYNkuFiuBuRj2mw0oWVUeQlHwgjulPAdkwGCTz1JMdDgyacs3jSAZOTVMez7AdcHQncKXNYBjXwahwFgNgFF0ABjZBJTE0AjJMszhSsmzUWhHJQAZbhoTony5G4Zg1GhDjQH4WAAGtYGoAB3Ec+UTZib1YwLQAAoCFFAUwQrCyKYtgfi5FMfj4sdNcsAc0zzJcyUpLICqnIsjBrMlXAAG9QAEYQ6DUCoAF9QDVdrH26w5QF6gyAHEMGQAB5NBXNgbRpim2b5slYYZorAArOjMqa6gFEoXAmwUAC6AmTMPNahlSX4gBpDAXwA0Bwse6h1FATadv44lBC4Vr+q40AAAU4Us8LcC+jIHqcUoYbuGMRWJKk1C+0kYdXRBev0Zbprmha+n1CMyBW-H1q0NrsUWssMDUE6ztcJ5BDoDAZD5csMNccbIWAFbzFiOE70oaY4Ugfn+EFjAjvhoHXvgd7Pu2jIvo8hkAbo0HwchpXQBh4g5ERu4YbK0A+YwAWhe1nagfMSyDqO+n6Aupwrs84l0ce1KRzlhWvvBLhRfFyXpce5XtsIClUe2j34HA7HceQIOhdq03pqTqXKaeanadAR26EZ8EWbZ0BdIULmDPMMtqCFUzKBYABlOE6EW5B+DvaZK+rjBa4bpuW7b88-Zt-bDuOxQzudwgruxW72Xh56fY+v2fv93XPaBgADAASVq0urevFF6je5APjKSttJ5I8VraY-pePtU7muOF75vBFbu8U8f7vn+YRvX-f8810nikjlnTce9Ar6OALpAAcGA0DrDUAKagcJKDl1cCAAAwloP6kBgb8ArFoMGwMFDUDQJARAllsGQC4AAEVoHQUAQDQBoHwYQyyJcfw5zzgXNAJC2DWSloXHOpceGnQFG-LAi5qAVgrHCCwYDTr0F3J0J4dtYAnX4NZA65wmFPCXKLV82dbBUHoeQAuejFwGOZlgMgvgAAM5j5CWMgK+KRMi5FcDILOGBGA4FgnIPeZAK4C7Y3vmKLBOC8EEKISQshKcInUKiWw4hpDIC4DofQKY0wEm4NYTE1JVs6K23tmPRR51wSXVsLor089vZvSXttK+aMMbEixjjIAA" target="_blank" rel="noreferrer">TS Playground汇总</a></li></ul><p>2023年03月14日13:47:47</p>',127),w=[f];function k(T,_,x,q,I,j){return o(),l("div",null,w)}const R=p(v,[["render",k]]);export{P as __pageData,R as default};
