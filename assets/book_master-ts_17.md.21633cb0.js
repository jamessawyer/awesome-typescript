import{_ as n}from"./chunks/10-13.153a4ea8.js";import{_ as p,c as o,o as l,O as e}from"./chunks/framework.5e952531.js";const s="/awesome-typescript/assets/17-1.02d82f84.webp",a="/awesome-typescript/assets/17-2.58d49f7f.webp",t="/awesome-typescript/assets/17-4.b158c798.webp",r="/awesome-typescript/assets/17-3.2598955b.webp",c="/awesome-typescript/assets/17-5.2fe0e7ff.webp",i="/awesome-typescript/assets/17-6.2d99d34c.webp",v=JSON.parse('{"title":"逆变，协变，双向协变，不变","description":"","frontmatter":{"title":"逆变，协变，双向协变，不变"},"headers":[],"relativePath":"book/master-ts/17.md","lastUpdated":1682407907000}'),y={name:"book/master-ts/17.md"},C=e(`<p>深入学习 TypeScript 类型系统的话，<code>逆变、协变、双向协变、不变</code>是绕不过去的概念。</p><p>这些概念看起来挺高大上的，其实并不复杂，这节我们就来学习下它们吧。</p><h2 id="类型安全和型变" tabindex="-1">类型安全和型变 <a class="header-anchor" href="#类型安全和型变" aria-label="Permalink to &quot;类型安全和型变&quot;">​</a></h2><p>TypeScript 给 JavaScript 添加了一套静态类型系统，是为了保证类型安全的，也就是保证变量只能赋同类型的值，对象只能访问它有的属性、方法。</p><p>比如 number 类型的值不能赋值给 boolean 类型的变量，Date 类型的对象就不能调用 exec 方法。</p><p>这是类型检查做的事情，遇到类型安全问题会在编译时报错。</p><p>但是这种类型安全的限制也不能太死板，有的时候需要一些变通，比如子类型是可以赋值给父类型的变量的，可以完全当成父类型来使用，也就是“型变（<code>variant</code>）”（类型改变）。</p><p>这种“型变”分为两种:</p><ol><li>一种是子类型可以赋值给父类型，叫做协变（<code>covariant</code>），</li><li>一种是父类型可以赋值给子类型，叫做逆变（<code>contravariant</code>）。</li></ol><p>先来看下协变</p><h2 id="协变-covariant" tabindex="-1">协变（covariant） <a class="header-anchor" href="#协变-covariant" aria-label="Permalink to &quot;协变（covariant）&quot;">​</a></h2><p>其中协变是很好理解的，比如我们有两个 interface：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Person</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">string</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">age</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">number</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Guang</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">string</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">age</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">number</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">hobbies</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">string</span><span style="color:#A6ACCD;">[]</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>这里 Guang 是 Person 的子类型，更具体，那么 Guang 类型的变量就可以赋值给 Person 类型：</p><p><img src="`+s+`" alt="协变"></p><p>这并不会报错，虽然这俩类型不一样，但是依然是类型安全的。</p><p>这种子类型可以赋值给父类型的情况就叫做协变。</p><p>为什么要支持协变很容易理解：<strong>类型系统支持了父子类型，那如果子类型还不能赋值给父类型，还叫父子类型么？</strong></p><p>所以型变是实现类型父子关系必须的，它在保证类型安全的基础上，增加了类型系统的灵活性。</p><p>逆变相对难理解一些：</p><h2 id="逆变-contravariant" tabindex="-1">逆变（contravariant） <a class="header-anchor" href="#逆变-contravariant" aria-label="Permalink to &quot;逆变（contravariant）&quot;">​</a></h2><p>我们有这样两个函数：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> printHobbies</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">guang</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Guang</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">void</span></span>
<span class="line"><span style="color:#82AAFF;">printHobbies</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">guang</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">guang</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">hobbies</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> printName</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">person</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Person</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">void</span></span>
<span class="line"><span style="color:#82AAFF;">printName</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">person</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">person</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>printHobbies 的参数 Guang 是 printName 参数 Person 的子类型。</p><p>那么问题来了，printName 能赋值给 printHobbies 么？printHobbies 能赋值给 printName 么？</p><p>测试一下发现是这样的：</p><p><img src="`+a+'" alt="逆变"></p><p>🤔printName 的参数 Person 不是 printHobbies 的参数 Guang 的父类型么，为啥能赋值给子类型？</p><ul><li>因为这个函数调用的时候是按照 Guang 来约束的类型，但实际上函数只用到了父类型 Person 的属性和方法，当然不会有问题，依然是类型安全的。</li><li><strong>这就是逆变，函数的参数有逆变的性质（而返回值是协变的，也就是子类型可以赋值给父类型）。</strong></li></ul><p>那反过来呢，如果 printHoobies 赋值给 printName 会发生什么？</p><ul><li>因为函数声明的时候是按照 Person 来约束类型，但是调用的时候是按照 Guang 的类型来访问的属性和方法，那自然类型不安全了，所以就会报错。</li></ul><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>但是在 ts2.x 之前支持这种赋值，也就是父类型可以赋值给子类型，子类型可以赋值给父类型，既逆变又协变，叫做“<strong>双向协变</strong>”。</p><p><img src="'+t+'" alt="strictFunctionTypes"></p><p>我们把 <a href="./../../ts/tsconfig/compiler/type-checking.html#strictfunctiontypes-👍">strictFunctionTypes</a> 关掉之后，就会发现两种赋值都可以了：</p><p><img src="'+r+'" alt="双向协变"></p><p>这样就支持函数参数的双向协变，类型检查不会报错，但不能严格保证类型安全。</p><p><strong>开启之后，函数参数就只支持逆变，子类型赋值给父类型就会报错</strong></p><p><img src="'+a+`" alt="逆变"></p></div><p>在类型编程中这种逆变性质有什么用呢？</p><p>还记得之前<a href="./10.html#uniontointersection">联合转交叉</a>的实现么？</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">UnionToIntersection</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">U</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span></span>
<span class="line"><span style="color:#A6ACCD;">  (</span><span style="color:#FFCB6B;">U</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">U</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">x</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">U</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">unknown</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">never</span><span style="color:#A6ACCD;">) </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">x</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">infer</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">R</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">unknown</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">R</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">never</span></span></code></pre></div><ul><li>类型参数 U 是要转换的联合类型。</li><li>U extends U 是为了触发联合类型的 distributive 的性质，让每个类型单独传入做计算，最后合并。</li><li>利用 U 做为参数构造个函数，通过模式匹配取参数的类型。</li><li>结果就是交叉类型：</li></ul><p><img src="`+n+'" alt="UnionToIntersection"></p><p>我们通过构造了多个函数类型，然后模式提取参数类型的方式，来实现了联合转交叉，<strong>这里就是因为函数参数是逆变的</strong>，会返回联合类型的几个类型的子类型，也就是更具体的交叉类型。</p><p>逆变和协变都是型变，是针对父子类型而言的，非父子类型自然就不会型变，也就是不变.</p><h2 id="不变-invariant" tabindex="-1">不变（invariant） <a class="header-anchor" href="#不变-invariant" aria-label="Permalink to &quot;不变（invariant）&quot;">​</a></h2><p>非父子类型之间不会发生型变，只要类型不一样就会报错：</p><p><img src="'+c+'" alt="非父子关系"></p><p>那类型之间的父子关系是怎么确定的呢，好像也没有看到 extends 的继承？</p><h2 id="类型父子关系的判断" tabindex="-1">类型父子关系的判断 <a class="header-anchor" href="#类型父子关系的判断" aria-label="Permalink to &quot;类型父子关系的判断&quot;">​</a></h2><p>像 java 里面的类型都是通过 extends 继承的，如果 A extends B，那 A 就是 B 的子类型。这种叫做名义类型系统（<code>nominal type</code>）。</p><p>📚 <strong>而 ts 里不看这个，只要结构上是一致的，那么就可以确定父子关系，这种叫做结构类型系统（<code>structual type</code>）。</strong></p><p>还是拿上面那个例子来说：</p><p><img src="'+s+'" alt="协变"></p><p>Guang 和 Person 有 extends 的关系么？</p><p>没有呀。</p><p>那是怎么确定父子关系的？</p><p>📚 <strong>通过结构，更具体的那个是子类型</strong>。这里的 Guang 有 Person 的所有属性，并且还多了一些属性，所以 Guang 是 Person 的子类型。</p><p>注意，这里用的是更具体，而不是更多。</p><p>判断联合类型父子关系的时候， <code>&#39;a&#39; | &#39;b&#39;</code> 和 <code>&#39;a&#39; | &#39;b&#39; | &#39;c&#39;</code> 哪个更具体？</p><p><code>&#39;a&#39; | &#39;b&#39;</code> 更具体，所以 <code>&#39;a&#39; | &#39;b&#39;</code> 是 <code>&#39;a&#39; | &#39;b&#39; | &#39;c&#39;</code> 的子类型。</p><p>测试下：</p><p><img src="'+i+'" alt="更具体的是子类型"></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>ts 通过给 js 添加了静态类型系统来保证了类型安全，大多数情况下不同类型之间是不能赋值的，但是为了增加类型系统灵活性，设计了父子类型的概念。父子类型之间自然应该能赋值，也就是会发生型变（<code>variant</code>）。</p><p>型变分为逆变（<code>contravariant</code>）和协变（<code>covariant</code>）。</p><ul><li>协变很容易理解，就是子类型赋值给父类型。</li><li>逆变主要是函数赋值的时候函数参数的性质，参数的父类型可以赋值给子类型，这是因为按照子类型来声明的参数，访问父类型的属性和方法自然没问题，依然是类型安全的。但反过来就不一定了。</li></ul><p>不过 ts 2.x 之前反过来依然是可以赋值的，也就是既逆变又协变，叫做<strong>双向协变</strong>。</p><p>为了更严格的保证类型安全，ts 添加了 <code>strictFunctionTypes</code> 的编译选项，开启以后函数参数就只支持逆变，否则支持双向协变。</p><p>型变都是针对父子类型来说的，非父子类型自然就不会型变也就是不变（invariant）。</p><p>ts 中父子类型的判定是<strong>按照结构</strong>来看的，更具体的那个是子类型。</p><p>理解了如何判断父子类型（结构类型系统），父子类型的型变（逆变、协变、双向协变），很多类型兼容问题就能得到解释了。</p><div class="tip custom-block"><p class="custom-block-title">以下关于ts逆变协变文章更加的好</p><ul><li><a href="https://github.com/jamessawyer/awesome/blob/main/typescript/%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98.md" target="_blank" rel="noreferrer">typescript-covariance-contravariance 中文</a></li><li><a href="https://dmitripavlutin.com/typescript-covariance-contravariance/" target="_blank" rel="noreferrer">原文 Covariance and Contravariance in TypeScript</a></li><li><a href="https://jkchao.github.io/typescript-book-chinese/tips/covarianceAndContravariance.html#%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E9%97%AE%E9%A2%98" target="_blank" rel="noreferrer">协变与逆变 - 深入理解TS</a></li></ul></div><p>2023年03月17日11:20:59</p>',68),D=[C];function F(A,d,g,m,u,b){return l(),o("div",null,D)}const _=p(y,[["render",F]]);export{v as __pageData,_ as default};
