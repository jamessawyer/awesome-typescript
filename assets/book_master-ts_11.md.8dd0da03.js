import{_ as s}from"./chunks/5-15.78edf22f.js";import{_ as a}from"./chunks/6-10.9294698a.js";import{_ as n}from"./chunks/7-13.1a959329.js";import{_ as p}from"./chunks/8-3.a04eabbd.js";import{_ as l,a as o}from"./chunks/9-5.2834a3d1.js";import{_ as e,a as t}from"./chunks/10-17.dd9c15a5.js";import{_ as r,c,o as y,N as C}from"./chunks/framework.90b54eba.js";const F="/awesome-typescript/assets/11-8.d4700710.webp",D="/awesome-typescript/assets/11-1.f3bd6a1c.webp",A="/awesome-typescript/assets/11-2.d065ee64.webp",i="/awesome-typescript/assets/11-3.21a63a94.webp",B="/awesome-typescript/assets/11-4.253fa573.webp",g="/awesome-typescript/assets/11-5.2dc702d7.webp",d="/awesome-typescript/assets/11-6.8c0ecb50.webp",m="/awesome-typescript/assets/11-7.d045f6e0.webp",R=JSON.parse('{"title":"类型体操顺口溜","description":"","frontmatter":{"title":"类型体操顺口溜"},"headers":[],"relativePath":"book/master-ts/11.md","lastUpdated":1678937517000}'),u={name:"book/master-ts/11.md"},h=C(`<p>TypeScript 类型编程难么？</p><p>难。不然怎么会被叫做类型体操呢。</p><p>但其实类型体操是有套路的，我把类型体操的各种套路总结成了一个顺口溜：</p><p><strong>类型体操顺口溜</strong></p><p><strong>模式匹配做提取，重新构造做变换。</strong></p><p><strong>递归复用做循环，数组长度做计数。</strong></p><p><strong>联合分散可简化，特殊特性要记清。</strong></p><p><strong>基础扎实套路熟，类型体操可通关。</strong></p><p>逐句解释下：</p><h2 id="模式匹配做提取" tabindex="-1">模式匹配做提取 <a class="header-anchor" href="#模式匹配做提取" aria-label="Permalink to &quot;模式匹配做提取&quot;">​</a></h2><p>就像字符串可以通过正则提取子串一样，TypeScript 的类型也可以通过匹配一个模式类型来提取部分类型到 infer 声明的局部变量中返回。</p><p>比如提取函数类型的返回值类型：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">GetReturnType</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Func</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Function</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">Func</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(...</span><span style="color:#A6ACCD;font-style:italic;">arg</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">any</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">infer</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">R</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">R</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">never</span></span>
<span class="line"></span></code></pre></div><p><img src="`+s+`" alt="ReturnType"></p><ul><li><a href="./5.html#getreturntype">参考 GetReturnType</a></li></ul><h2 id="重新构造做变换" tabindex="-1">重新构造做变换 <a class="header-anchor" href="#重新构造做变换" aria-label="Permalink to &quot;重新构造做变换&quot;">​</a></h2><p>TypeScript 类型系统可以通过 type 声明类型变量，通过 infer 声明局部变量，<strong>类型参数在类型编程中也相当于局部变量</strong>，但是它们都不能做修改，想要对类型做变换只能构造一个新的类型，在构造的过程中做过滤和转换。</p><p>在字符串、数组、函数、索引等类型都有很多应用，特别是索引类型。</p><p>比如把索引变为大写：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">UppercaseKey</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Obj</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Record</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">string</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">any</span><span style="color:#89DDFF;">&gt;&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  [</span><span style="color:#FFCB6B;">Key</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">in</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">keyof</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Obj</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Uppercase</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Key</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">string</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Obj</span><span style="color:#A6ACCD;">[</span><span style="color:#FFCB6B;">Key</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><img src="`+a+'" alt="UppercaseKey"></p><ul><li><a href="./6.html#⚡-uppercasekey">参考UppercaseKey</a></li></ul><h2 id="递归复用做循环" tabindex="-1">递归复用做循环 <a class="header-anchor" href="#递归复用做循环" aria-label="Permalink to &quot;递归复用做循环&quot;">​</a></h2><p>在 TypeScript 类型编程中，遇到数量不确定问题时，就要条件反射的想到递归，每次只处理一个类型，剩下的放到下次递归，直到满足结束条件，就处理完了所有的类型。</p><p>比如把长度不确定的字符串转为联合类型：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">StringToUnion</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Str</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">string</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">Str</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">`${</span><span style="color:#89DDFF;">infer</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">First</span><span style="color:#89DDFF;">}${</span><span style="color:#89DDFF;">infer</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Rest</span><span style="color:#89DDFF;">}`</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">First</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">StringToUnion</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Rest</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">never</span></span>\n<span class="line"></span></code></pre></div><p><img src="'+n+`" alt="StringToUnion"></p><ul><li><a href="./7.html#stringtounion">查看 StringToUnion</a></li></ul><h2 id="数组长度做计数" tabindex="-1">数组长度做计数 <a class="header-anchor" href="#数组长度做计数" aria-label="Permalink to &quot;数组长度做计数&quot;">​</a></h2><p>TypeScript 类型系统没有加减乘除运算符，但是可以构造不同的数组再取 <code>length</code> 来得到相应的结果。这样就把数值运算转为了数组类型的构造和提取。</p><p>比如实现减法：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">BuildArray</span><span style="color:#89DDFF;">&lt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">Length</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">number</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">Elm</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">unknown</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">Arr</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">unknown</span><span style="color:#A6ACCD;">[] </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> []</span></span>
<span class="line"><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">Arr</span><span style="color:#A6ACCD;">[</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">length</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">] </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Length</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Arr</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">BuildArray</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Length</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Elm</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> [</span><span style="color:#FFCB6B;">Elm</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...</span><span style="color:#FFCB6B;">Arr</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span></span>
<span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Subtract</span><span style="color:#89DDFF;">&lt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">Num1</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">number</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">Num2</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">number</span></span>
<span class="line"><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">BuildArray</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Num1</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> [</span><span style="color:#89DDFF;">...</span><span style="color:#FFCB6B;">arr1</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">BuildArray</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Num2</span><span style="color:#89DDFF;">&gt;,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...</span><span style="color:#FFCB6B;">arr2</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">infer</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Rest</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Rest</span><span style="color:#A6ACCD;">[</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">length</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">never</span></span>
<span class="line"></span></code></pre></div><p><img src="`+p+`" alt="Subtract"></p><ul><li><a href="./8.html#substract">查看 Subtract</a></li></ul><h2 id="联合分散可简化" tabindex="-1">联合分散可简化 <a class="header-anchor" href="#联合分散可简化" aria-label="Permalink to &quot;联合分散可简化&quot;">​</a></h2><p>TypeScript 对联合类型做了特殊处理，当遇到字符串类型或者作为类型参数出现在条件类型左边的时候，会分散成单个的类型传入做计算，最后把计算结果合并为联合类型。</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">UppercaseA</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Item</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">string</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">Item</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">a</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Uppercase</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Item</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Item</span></span>
<span class="line"></span></code></pre></div><p><img src="`+l+`" alt="UppercaseA"></p><ul><li><a href="./9.html#分布式条件类型">查看UppercaseA</a></li></ul><p>这样虽然简化了类型编程，但也带来了一些认知负担。</p><p>比如联合类型的判断是这样的：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">IsUnion</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">A</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">B</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">A</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">A</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">A</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> [</span><span style="color:#FFCB6B;">B</span><span style="color:#A6ACCD;">] </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> [</span><span style="color:#FFCB6B;">A</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">false</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">true</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">never</span></span>
<span class="line"></span></code></pre></div><p><img src="`+o+`" alt="IsUnion"></p><ul><li><a href="./9.html#⚡-isunion">查看IsUnion</a></li></ul><p>联合类型做为类型参数直接出现在条件类型<strong>左边</strong>的时候就会触发 distributive 特性，而不是直接出现在左边的时候不会。</p><p>所以， A 是单个类型、B 是整个联合类型。通过比较 A 和 B 来判断联合类型。</p><h2 id="特殊特性要记清" tabindex="-1">特殊特性要记清 <a class="header-anchor" href="#特殊特性要记清" aria-label="Permalink to &quot;特殊特性要记清&quot;">​</a></h2><p>会了提取、构造、递归、数组长度计数、联合类型分散这 5 个套路以后，各种类型体操都能写，但是有一些特殊类型的判断需要根据它的特性来，所以要重点记一下这些特性。</p><p>比如 any 和任何类型的交叉都为 any，可以用来判断 any 类型：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">IsAny</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">T</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">x</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> (</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">y</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">T</span><span style="color:#A6ACCD;">) </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">true</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">false</span></span>
<span class="line"></span></code></pre></div><p><img src="`+e+`" alt="IsAny"></p><ul><li><a href="./10.html#isany">查看IsAny</a></li></ul><p>比如索引一般是 string，而可索引签名不是，可以根据这个来过滤掉可索引签名：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">RemoveIndexSignature</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Obj</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Record</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">string</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">any</span><span style="color:#89DDFF;">&gt;&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  [</span><span style="color:#FFCB6B;">Key</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">in</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">keyof</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Obj</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#FFCB6B;">as</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Key</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">etends</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">\`\${</span><span style="color:#89DDFF;">infer</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Str</span><span style="color:#89DDFF;">}\`</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">Str</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">never</span></span>
<span class="line"><span style="color:#A6ACCD;">  ]</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Obj</span><span style="color:#A6ACCD;">[</span><span style="color:#FFCB6B;">Key</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><img src="`+t+'" alt="RemoveIndexSignature"></p><ul><li><a href="./10.html#removeindexsignature">查看RemoveIndexSignature</a></li></ul><h2 id="基础扎实套路熟-类型体操可通关" tabindex="-1">基础扎实套路熟，类型体操可通关 <a class="header-anchor" href="#基础扎实套路熟-类型体操可通关" aria-label="Permalink to &quot;基础扎实套路熟，类型体操可通关&quot;">​</a></h2><p>基础指的是 TypeScript 类型系统中的各种类型，以及可以对它们做的各种类型运算逻辑，这是类型编程的原材料。</p><p>但是只是会了基础不懂一些套路也很难做好类型编程，所以要熟悉上面 6 种套路。</p><p>基础扎实、套路也熟了之后，各种类型编程问题都可以搞定，也就是“通关”。</p><h2 id="练练手" tabindex="-1">练练手 <a class="header-anchor" href="#练练手" aria-label="Permalink to &quot;练练手&quot;">​</a></h2><p>在讲 “TypeScript 类型编程为什么被叫做类型体操” 的时候我举了一个 ParseQueryString 的类型例子，用来说明类型编程的复杂度。</p><p><img src="'+F+'" alt="ParseQueryString"></p><p>学完了所有套路之后，我们来实现下这个类型：</p><h2 id="⚡-parsequerystring" tabindex="-1">⚡ ParseQueryString <a class="header-anchor" href="#⚡-parsequerystring" aria-label="Permalink to &quot;⚡ ParseQueryString&quot;">​</a></h2><p><code>a=1&amp;b=2&amp;c=3&amp;d=4</code>，这样的字符串明显是 query param <strong>个数不确定</strong>的，遇到数量不确定的问题，条件反射的就要想到递归：</p><p>递归解析出每一个 query params，也就是 <code>&amp;</code> 分隔的每个字符串，每个字符串单独去解析，构造成索引类型，最后把这些所有的单个索引类型合并就行。</p><p>也就是这样的：</p><p><img src="'+D+'" alt="overview"></p><ul><li>第一步并不知道有多少个 a=1、b=2 这种 query param，要递归的做模式匹配来提取。</li><li>然后每一个 query param 再通过模式匹配取出 key 和 value，构造成索引类型。</li><li>然后把每个索引类型合并成一个大的索引类型就可以了。</li></ul><p>思路理清了，我们一步步来实现下。</p><p>1️⃣ 首先，要递归的提取 <code>&amp;</code> 分隔的 query param：</p><p><img src="'+A+'" alt="递归提取"></p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ParseQueryString</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Str</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">string</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">Str</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">`${</span><span style="color:#89DDFF;">infer</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Param</span><span style="color:#89DDFF;">}</span><span style="color:#C3E88D;">&amp;</span><span style="color:#89DDFF;">${</span><span style="color:#89DDFF;">infer</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Rest</span><span style="color:#89DDFF;">}`</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">MergeParams</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">ParseParam</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Param</span><span style="color:#89DDFF;">&gt;,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ParseQueryString</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Rest</span><span style="color:#89DDFF;">&gt;&gt;</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ParseParam</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Str</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"></span></code></pre></div><ul><li>类型参数 Str 为待处理的 query 字符串，通过 extends 约束为 string 类型。</li><li>提取 &amp; 分割的字符串到 infer 声明的局部变量 Param 里，后面的字符串放到 Rest 里。</li><li>通过 <code>ParseParam</code> 来处理单个的 query param，剩下 query 字符串也是一样的递归处理，然后把这些处理结果合并到一起，也就是 <code>MergeParams</code>。</li><li>当提取不出 &amp; 分割的字符串时递归结束，把剩下的字符串也用 ParseParam 来处理。</li></ul><p>2️⃣ <code>ParseParam</code> 的实现就是提取和构造：</p><p><img src="'+i+`" alt="ParseParam提取和构造"></p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ParseParam</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Param</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">string</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">Param</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">\`\${</span><span style="color:#89DDFF;">infer</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Key</span><span style="color:#89DDFF;">}</span><span style="color:#C3E88D;">=</span><span style="color:#89DDFF;">\${</span><span style="color:#89DDFF;">infer</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Value</span><span style="color:#89DDFF;">}\`</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        [</span><span style="color:#FFCB6B;">K</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">in</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Key</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Value</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"></span></code></pre></div><ul><li>类型参数 Param 类单个的 query param，比如 a=1 这种。</li><li>通过模式匹配提取 key 和 value 到 infer 声明的局部变量 Key、Value 里。</li><li>通过映射类型语法构造成索引类型返回：</li></ul><p><img src="`+B+'" alt="ParseParam"></p><p>3️⃣ 每个 query param 处理完了，最后把这一系列构造出的索引类型合并成一个就行了：</p><p><img src="'+g+`" alt="索引合并"></p><p>这也是构造索引类型：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">MergeParams</span><span style="color:#89DDFF;">&lt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">OneParam</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Record</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">string</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">any</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">OtherParam</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Record</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">string</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">any</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  [</span><span style="color:#FFCB6B;">Key</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">in</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">keyof</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">OneParam</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">keyof</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">OtherParam</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#FFCB6B;">Key</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">keyof</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">OneParam</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Key</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">keyof</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">OtherParam</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">MergeValues</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">OneParams</span><span style="color:#A6ACCD;">[</span><span style="color:#FFCB6B;">Key</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">OtherParams</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Key</span><span style="color:#89DDFF;">&gt;&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">OneParam</span><span style="color:#A6ACCD;">[</span><span style="color:#FFCB6B;">Key</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Key</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">keyof</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">OtherParams</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">OtherParam</span><span style="color:#A6ACCD;">[</span><span style="color:#FFCB6B;">Key</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">never</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><ul><li><p>类型参数 OneParam、OtherParam 是要合并的 query param，约束为索引类型（索引为 string，索引值为任意类型。</p></li><li><p>构造一个新的索引类型返回，索引来自两个的合并，也就是 <code>Key in keyof OneParam | keyof OtherParam</code>。</p></li><li><p><code>MegeValues</code> 的合并逻辑就是如果两个值是同一个就返回一个，否则构造一个数组类型来合并：</p></li></ul><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">MergeValues</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">One</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Other</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">One</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Other</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">One</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Other</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">unknown</span><span style="color:#A6ACCD;">[]</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> [</span><span style="color:#FFCB6B;">One</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...</span><span style="color:#FFCB6B;">Other</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> [</span><span style="color:#FFCB6B;">One</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Other</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"></span></code></pre></div><ul><li>类型参数 One、Other 是要合并的两个值。</li><li>如果两者是同一个类型，也就是 One extends Other，就返回任意一个。</li><li>否则，如果是数组就做数组合并，否则构造一个数组把两个类型放进去。</li></ul><p>我们单独测试下索引合并：</p><p><img src="`+d+'" alt="MergeParams"></p><p>每个 query param 的解析和构造索引类型，多个索引类型的合并都实现了，合并起来也就实现了 query string 的解析：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ParseQueryString</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Str</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">string</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">Str</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">`${</span><span style="color:#89DDFF;">infer</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Param</span><span style="color:#89DDFF;">}</span><span style="color:#C3E88D;">&amp;</span><span style="color:#89DDFF;">${</span><span style="color:#89DDFF;">infer</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Rest</span><span style="color:#89DDFF;">}`</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">MergeParams</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">ParseParam</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Param</span><span style="color:#89DDFF;">&gt;,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ParseQueryString</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Rest</span><span style="color:#89DDFF;">&gt;&gt;</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ParseParam</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Str</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"></span></code></pre></div><p><img src="'+m+'" alt="ParseQueryString"></p><p>在实现 ParseQueryString 的类型的时候，我们大量用到了<code>模式匹配做提取</code>、<code>重新构造做变换</code>、<code>递归复用做循环</code>这 3 大套路，思路理清之后利用这些套路能够很顺畅的把这个高级类型写出来。</p><p>这是最开始被我用来说明类型编程复杂度的例子，是有一定复杂度的，而学到这我们也能实现了。</p><p>再回到最开始的问题：</p><p>TypeScript 类型编程难么？</p><p>其实熟悉一些套路以后，也没那么难。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>为了方便记忆，我总结了类型体操顺口溜，然后分别解释了每句话的含义，之后又做了一个类型体操来练手。</p><p>那个最开始被我用来说明 TypeScript 类型编程复杂度的例子，现在我们也能顺畅的实现了，所用的就是类型体操顺口溜中的套路。</p><p>这就像武功秘籍一样，理解了每句话的含义，反复修炼，就能成为类型体操的武林高手：</p><p><strong>模式匹配做提取，重新构造做变换。</strong></p><p><strong>递归复用做循环，数组长度做计数。</strong></p><p><strong>联合分散可简化，特殊特性要记清。</strong></p><p><strong>基础扎实套路熟，类型体操可通关。</strong></p><ul><li><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBACghgJwM4XguBbAPGzUIAewEAdgCZJRLAICWJA5gHxQC8UAUFN7InocXKUABgBIA3vQBmEBFADSEEAF9WE6bKgA1OABsArhGXCuPMwH4o402dtQA2vKj0FSgLoAubXsOc73ZSgvcWUAbg4OUEheZFQ+DAAlCCR9XWA2GJRcbAByOFYARhymcMjwaABZWQYIHQNkrAB5EggAGihG4AALWRZ2Gw6W-CJSCg7uzQGLQYgpni9OnrkBUcp9EgBrEgB7AHcSezc5u0t7ZraoADprxdkj-1svM5b224Q3UqjK6rj0DCQsANztlhoIxkkAMbbBBkLDUOiMdpwEggJitIETBAglZCKCQ6Gw+H0BhIlFMDh9KymRxKZwkKAbJTbKQzEEAHwZTJZb2ynj8PEUIFBq05IGZrPixyglkFwtxjLF3Mx2Sl0yqCBqdUMAOB8RpIDcr2VesFbnJDzMCxa2X1938XllOLGCvFPPi-It0vGSxtpo9Fq8LQAbrIOMoIl8oOqatkkEkUmkMtHfpgAeIoHAvAUoMp2umAEZeABMOZKEfKmQgAEVDAgQABlGjErCN5YjXFExiUgatuVjMSSEgyOTZZQAMnUQ808eAxillmTsZwiCy8WXfzRlZrsgbTcYWBnTHN9sr2RbNDL5eiaBQ27rreJ8dS6XYN+rtd3CIYWDyhTH+SLMd81YQCIVYABmYpSg4IA" target="_blank" rel="noreferrer">TS Playground合集</a></li></ul><p>2023年03月15日14:13:00</p>',107),b=[h];function E(P,f,_,x,S,k){return y(),c("div",null,b)}const U=r(u,[["render",E]]);export{R as __pageData,U as default};
